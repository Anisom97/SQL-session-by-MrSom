-- DATATYPES
-- INT, FLOAT, DOUBLE - for numbers  (bigint, smallint)
-- CHAR, VARCHAR() - for string    
-- DATE, DATETIME, DATETIMESTAMP - for date type 

-- DROP TABLE Persons;

CREATE TABLE Persons (   -- CREATES AN EMPTY TABLE 
    PersonID int,
    LastName varchar(255),
    FirstName varchar(255),
    Address varchar(255),
    City varchar(255)
);

SELECT * FROM Persons;  -- VIEW THE EMPTY TABLE

----------------------------------
-- DROP TABLE TRANS_V2;

CREATE TABLE TRANS_V2 (     --SYNTAX FOR CREATING AN EMPTY TABLE , SPECIFY THE NAME OF THE TABLE NAME
TNXID INT,              --ASSIGN APPROPRIATE DATATYPES TO THE COLUMNS CREATED (BASICALLY WHAT TYPE OF DATA YOU WANT TO STORE)
PRODUCTDESC VARCHAR(255),
PRICE FLOAT
);

INSERT INTO TRANS_V2       --FILL IN INFORMATION INTO THE TABLE CREATED (HERE ITS TRANSACION TABLE)
VALUES                  -- ALL VALUES SHOULD BE STORED IN ORDER OF THE COLUMN NAMES
(1001,'TSHIRT',100.50), -- DATATYPES OF THE COLUMNS AND THE VALUES IN IT SHOULD BE SAME
(1002,'SHIRT',50),
(1003,'PANT',40);


SELECT * FROM TRANS_V2;    --VIEW THE ENTIRE TABLE WITH ALL THE INFORMATION/DATA

---------------------------------------------------
CREATE DATABASE ECOMMERCE;    -- CREATING A DATABASE

USE ECOMMERCE;   -- GET INSIDE THAT DATABASE

-- DROP TABLE TRANS;

CREATE TABLE TRANS (     --SYNTAX FOR CREATING AN EMPTY TABLE , SPECIFY THE NAME OF THE TABLE NAME
TNXID INT PRIMARY KEY, --ASSIGN APPROPRIATE DATATYPES TO THE COLUMNS CREATED (BASICALLY WHAT TYPE OF DATA YOU WANT TO STORE)
PRODUCTID VARCHAR(255),
PRODUCTDESC VARCHAR(255),
PRICE FLOAT
);

INSERT INTO TRANS      -- FILL IN INFORMATION INTO THE TABLE CREATED (HERE ITS TRANSACION TABLE)
VALUES                  -- ALL VALUES SHOULD BE STORED IN ORDER OF THE COLUMN NAMES
(1001,'P1','TSHIRT',100.50), -- DATATYPES OF THE COLUMNS AND THE VALUES IN IT SHOULD BE SAME
(1002,'P2','SHIRT',50),
(1003,'P3','PANT',40),
(1004,'P4','SAREE',120),
(1005,'P5','TOP',110),
(1006,'P6','TSHIRT',60),
(1007,'P1','TSHIRT',90),
(1008,'P3','PANT',50),
(1009,'P7','TSHIRT',70)
;

SELECT * FROM TRANS;    --VIEW THE ENTIRE TABLE WITH ALL THE INFORMATION/DATA

--USE TRANS;
ALTER TABLE TRANS ADD DISCOUNT INT; 
--ALTER TABLE TRANS ADD QTY INT AFTER PRODUCTDESC;

--ALTER TABLE TRANS RENAME DISCOUNT TO DISC_PEC;  MYSQL SYNTAX
EXEC SP_RENAME 'TRANS.DISCOUNT', 'DISC_PEC', 'COLUMN';  --SQL SERVER SYNTAX

--Alter table table_name modify column column_name varchar(30);  MYSQL SYNTAX
-- ALTER TABLE dbo.TRANS ALTER COLUMN TNXID VARCHAR (255);


UPDATE TRANS SET DISC_PEC=10 WHERE TNXID=1001;
UPDATE TRANS SET DISC_PEC=15 WHERE TNXID=1002;
UPDATE TRANS SET DISC_PEC=5 WHERE TNXID=1003;
UPDATE TRANS SET DISC_PEC=20 WHERE TNXID=1004;
UPDATE TRANS SET DISC_PEC=8 WHERE TNXID=1005;
UPDATE TRANS SET DISC_PEC=12 WHERE TNXID=1006;
UPDATE TRANS SET DISC_PEC=11 WHERE TNXID=1007;
UPDATE TRANS SET DISC_PEC=15 WHERE TNXID=1008;
UPDATE TRANS SET DISC_PEC=5 WHERE TNXID=1009;

SELECT * FROM TRANS;  -- SELECT ALL COLUMNS FROM TABLE

SELECT TNXID, PRODUCTDESC FROM TRANS;  -- SELECT SPECIFIED COLUMNS FROM TABLE

SELECT T.TNXID, T.PRODUCTDESC FROM TRANS AS T;  -- READING SPECIFIC (ONLY REQUIRED) COLUMNS FROM THE TABLE WITH TABLE RENAME

-- WAREHOUSE_NAME.DATABASE_NAME.SCHEMA_NAME.TABLE_NAME AS N  -- INDUSTRY STANDARD OF WRITING TABLE NAMES

SELECT TOP 2 * FROM TRANS;
--SELECT * FROM TRANS LIMIT 2;

-------------#########################--------------
-------------#########################--------------

-- DATA FILTERING OPERATIONS ----------------------------
select * from trans;

SELECT * FROM TRANS WHERE PRICE>100;  --filterig out all the transactions where price of product purchased was > 50

SELECT PRODUCTDESC, PRICE FROM TRANS WHERE PRICE>=50;

SELECT DISTINCT PRODUCTDESC FROM TRANS WHERE PRICE>=50;  -- DISTINCT gives the Unique values in that particular column

SELECT 
		PRODUCTDESC
		--, PRODUCTID 
			FROM TRANS 
		WHERE PRICE>=50 
		--AND PRICE<=100
		; -- SPECIFY RANGE IN THE FILTER

SELECT 
	PRODUCTDESC
	, PRODUCTID 
		FROM TRANS 
	WHERE 
	PRICE>=50 
	AND PRICE<=100 
	AND DISC_PEC>10 
	AND DISC_PEC<20;  -- FILTERING ON THE BASIS OF MULTIPLE COLUMNS

--SELECT * FROM TRANS;
--OPERATORS SYNTAX - >, <, >=, <=, = , ! (NOT), IS NOT
--SELECT {SPECIFY THE COLUMN NAMES WITH comma THAT YOU WANT TO SEE AS OUTPUT} FROM TABLE_NAME CONDITIONS;

--SELECT * FROM TRANS WHERE PRICE>=50 AND PRICE<=100;

SELECT 
	PRODUCTID
	, PRODUCTDESC 
		FROM TRANS 
	WHERE 
	PRICE BETWEEN 50 AND 100 
	AND DISC_PEC BETWEEN 10 AND 15;  -- ANOTHER WAY OF SPECIFYING RANGE FOR ONE COLUMN

SELECT * FROM TRANS WHERE PRODUCTDESC IN ('TSHIRT','SHIRT'); 
SELECT * FROM TRANS WHERE PRODUCTDESC='TSHIRT' OR PRODUCTDESC='SHIRT';
SELECT * FROM TRANS;

SELECT *            --GETTING ALL COLUMNS 
		FROM TRANS 
			WHERE  --FILTERING OPERATIONS START
			PRODUCTID IN ('P1','P2','P3')    --FILTER 1
			AND PRICE>50   --FILTER 2 -- FOR ADDING MORE FILTERS USE AND
			AND DISC_PEC>10;  --FILTER 3

SELECT * FROM TRANS ORDER BY PRICE; -- DEFAULT IS ASCENDING
SELECT * FROM TRANS ORDER BY PRICE DESC ;


SELECT * FROM TRANS ORDER BY PRICE, DISC_PEC;
SELECT * FROM TRANS ORDER BY PRICE DESC, DISC_PEC;

SELECT DISTINCT PRODUCTID FROM TRANS;

INSERT INTO TRANS       --FILL IN INFORMATION INTO THE TABLE CREATED (HERE ITS TRANSACION TABLE)
VALUES                  -- ALL VALUES SHOULD BE STORED IN ORDER OF THE COLUMN NAMES
(1010,'P1','TSHIRT',NULL,NULL)
;

SELECT * FROM TRANS;

SELECT * FROM TRANS WHERE PRICE IS NOT NULL;  -- SHOW ME ALL THE RECORDS WHERE PRICE IS NOT NULL I.E. PRICE HAS ALWAYS BEEN CAPTURED

SELECT *
		, ISNULL(PRICE,50) AS UPDT_PRC 
			FROM TRANS;

SELECT *, COALESCE(PRICE,100) AS UPDT_PRC2 FROM TRANS;

SELECT * FROM TRANS;
-- SELECT *, COALESCE(RETUR_INITIATED,RETURN_ACCPTED, RETURN_RECIEVD_BY_COMPANY) AS UPDT_PRC2 FROM TRANS;

-- Bucket the products as per price ranges as high, medium and low 
--drop view TRANSAC_PRC;
GO
CREATE VIEW TRANSAC_PRC 
AS 
SELECT *  --BASE TRANSAC
	, CASE        -- DEFINING CONDITIONS 
	WHEN PRICE>100 THEN 'HIGH'  -- IF ELSE STATEMENTS 
	WHEN PRICE>50 AND PRICE<100 THEN 'MEDIUM'
	ELSE 'LOW'
	END AS PRICE_CLASS    -- THE NEW COLUMN CREATED WILL BE UPDATED IN THE TABLE(VIEW TRANSAC_PRC) AND THE COLUMN WILL STAY
	FROM TRANS ; 
GO

SELECT * FROM TRANS;

--DROP VIEW TRANSAC_PRC;
SELECT * FROM TRANSAC_PRC;

--DROP VIEW TRANSAC_PRC_CLASS;
-- Make product categories and classify the items

--CREATE OR REPLACE VIEW NAME_OF_VIEW AS (       )
GO
CREATE VIEW TRANSAC_PRC_CLASS AS
SELECT *     -- * HERE IS ALL COLUMNS FROM THE NEW TABLE TRANSAC_PRC
		, CASE 
		WHEN PRODUCTDESC IN ('TSHIRT','SHIRT') THEN 'MENS WEAR'
		WHEN PRODUCTDESC IN ('SAREE','TOP') THEN 'WOMEN WEAR'
		WHEN PRODUCTDESC IN ('PANT') THEN 'UNISEX'
		ELSE 'UNK'
		END AS PRODUCT_CLASS
		FROM TRANSAC_PRC;  -- USING THE LAST CREATED TABLE AM UPDATING IT AGAIN WITH A NEW COLUMN
GO

SELECT * FROM TRANSAC_PRC_CLASS; -- FROM BASE TABLE TRANS, WE CREATED NEW TABLE 1 I.E. TRANSAC_PRC , AND AGAIN FROM TRANSAC_PRC 
-- WE CREATED NEW TABLE 2 I.E. TRANSAC_PRC_CLASS

GO
CREATE VIEW TRANS_PRC_CLASS
AS
SELECT *
		, CASE        -- DEFINING CONDITIONS 
		WHEN PRICE>100 THEN 'HIGH'  -- IF ELSE STATEMENTS 
		WHEN PRICE>50 AND PRICE<100 THEN 'MEDIUM'
		ELSE 'LOW'
		END AS PRICE_CLASS   -- PRICE BUCKING COLUMN CREATED
		, CASE 
		WHEN PRODUCTDESC IN ('TSHIRT','SHIRT') THEN 'MENS WEAR'
		WHEN PRODUCTDESC IN ('SAREE','TOP') THEN 'WOMEN WEAR'
		WHEN PRODUCTDESC IN ('PANT') THEN 'UNISEX'
		ELSE 'UNK'
		END AS PRODUCT_CLASS  -- PRODUCT CATEGORY/CLASS COLUMN CREATED
		FROM TRANS;
GO

SELECT * FROM TRANS_PRC_CLASS;
SELECT * FROM TRANSAC_PRC_CLASS;

-- https://www.w3schools.com/sql/sql_like.asp 

--SELECT *, CASE  FROM (
SELECT * FROM TRANSAC_PRC_CLASS
		WHERE PRODUCT_CLASS LIKE '%MEN%' 
		;

SELECT * FROM TRANSAC_PRC_CLASS;
SELECT * FROM TRANSAC_PRC_CLASS WHERE PRODUCT_CLASS LIKE '%WEAR%';
SELECT PRODUCTID, PRICE FROM TRANSAC_PRC_CLASS WHERE PRODUCT_CLASS LIKE '%WEAR%' ;

SELECT * FROM TRANSAC_PRC_CLASS
		WHERE PRODUCT_CLASS LIKE 'M%';

-----------------------------------------
---- AGGREGATION FUNCTIONS -----

-- Want to see how many transactions had price >100
SELECT COUNT(*) FROM TRANSAC_PRC_CLASS WHERE PRICE>100;

SELECT * FROM TRANSAC_PRC_CLASS;
SELECT * FROM TRANSAC_PRC_CLASS WHERE PRICE>100;

SELECT DISTINCT PRODUCTDESC FROM TRANSAC_PRC_CLASS;

-- Want to see total number of txns that happened per product description 
SELECT PRODUCTDESC
		, COUNT(TNXID) AS NUM_OF_TRANS    -- GIVES ME THE COUNT OF purchases UNDER THE individual groups IN PRODUCTDESC
			FROM TRANSAC_PRC_CLASS 
	   GROUP BY PRODUCTDESC;

SELECT * FROM TRANSAC_PRC_CLASS ORDER BY PRODUCTDESC DESC;

--SELECT * FROM TRANSAC_PRC_CLASS;

-- want to see the all the product descriptions which has >3 no. of transactions  
SELECT PRODUCTDESC
		, COUNT(TNXID) AS NO_OF_TRANS 
			FROM TRANSAC_PRC_CLASS 
		GROUP BY PRODUCTDESC 
		HAVING COUNT(TNXID)>3;   -- FOR AGGREGATE FUNCTIONS USE HAVING AND NOT WHERE -- WHENEVER YOU WANT TO FILTER ON AGGREGATED VALUES USE HAVING


-- Want to see the no. of distinct products we have under every product description
SELECT PRODUCTDESC
		, COUNT(DISTINCT PRODUCTID) AS NUM_OF_PRODS -- GIVES ME THE COUNT OF UNIQUE PRODUCTS UNDER THE INDIVIDUAL GROUPS/UNIQUE RECORDS IN PRODUCTDESC
			FROM TRANSAC_PRC_CLASS 
		GROUP BY PRODUCTDESC;


SELECT * FROM TRANSAC_PRC_CLASS;


-- How much revenue did we generate from every product 
SELECT PRODUCTID
		, SUM(PRICE) AS TOTAL_REV
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCTID;

SELECT PRODUCT_CLASS     -- First specify whatever you want to see in the output table
		, PRODUCTDESC
		, SUM(PRICE) TOTAL_REV
		, AVG(PRICE) AVG_REV
		FROM TRANSAC_PRC_CLASS   -- from where I want to see it i.e. from the table
		GROUP BY 
			PRODUCT_CLASS
			, PRODUCTDESC   
		ORDER BY   -- how you want to see it
			PRODUCT_CLASS
			, PRODUCTDESC
;
-- Order of execution of query: from, where, group by, having, select, order by 

SELECT A.PRODUCT_CLASS     -- First specify whatever you want to see in the output table
		, A.PRODUCTDESC
		, SUM(A.PRICE) TOTAL_REV
		, AVG(A.PRICE) AVG_REV
		FROM 
		(SELECT * FROM TRANSAC_PRC_CLASS WHERE PRICE IS NOT NULL) A  -- from where I want to see it i.e. from the table
		GROUP BY 
			A.PRODUCT_CLASS
			, A.PRODUCTDESC   
		ORDER BY   -- how you want to see it
			A.PRODUCT_CLASS
			, A.PRODUCTDESC
;

SELECT * FROM TRANSAC_PRC_CLASS;

-- How much AVERAGE revenue did we generate from every product class
SELECT PRODUCT_CLASS
		, AVG(PRICE) AS MEAN_REVENUE_GENERATED
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCT_CLASS;

-- for every product id, what was the max. discount given
SELECT PRODUCTID
		, MAX(DISC_PEC) AS MAX_DISCOUNT_GIVEN  --min 
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCTID;

SELECT * FROM TRANSAC_PRC_CLASS;

-- for every productdesc, under every product class, what is the total rev generated and the total dis given
SELECT PRODUCT_CLASS        -- ALWAYS SPECIFY ALL THE AGGREGATIONS AFTER THE GROUPS AND BEFORE THE FROM STATEMENTS -- THE ORDER OF GROUP BY SHOULD BE THE SAME AS ORDER OF THE INPUT SEQUENCE AFTER SELECT
		, PRODUCTDESC
		, SUM(PRICE) AS TOTAL_REVENUE
		, SUM(DISC_PEC) AS TOTAL_DISCOUNT_GIVEN
		FROM TRANSAC_PRC_CLASS
		GROUP BY 
		PRODUCT_CLASS,
		PRODUCTDESC
		ORDER BY PRODUCT_CLASS,PRODUCTDESC;

------------------------------
-----#############-------
---- JOINS ----

CREATE TABLE ORD_CUST_DETAILS (     -- CREATING 2 TABLES FOR JOINS
TNXID INT PRIMARY KEY,    
CUST_EMAIL VARCHAR(255),
CUST_ADDRESS VARCHAR(255),
CUST_CITY VARCHAR(255),
);

INSERT INTO ORD_CUST_DETAILS       -- CUSTOMER DETAILS
VALUES                  
(1001,'ABC@GMAIL.COM','ACC HOUSE','BOM'), 
(1003,'A12@YAHOO.COM','CV NAGAR','AHMD'),
(1004,'XYZ@HOTMAIL.COM','ST PAULS ROAD','IXC'),
(1002,'qwe@gmail.com','Kalyan nagar','BOM'),
(1005,'rty@yahoo.com','BTM','CHN'),
(2011,'kkr@gmail.com','bly nest','CCU'),
(1007,'FCB@YAHOO.COM','BEL RD','CCU'),
(2008,'RMA@zoho.com','xz area','DEL'),
(1009,'ram@rediffmail.com','abc zone','GWT')
;

CREATE TABLE LOC_DETAILS (     
LOC_NAME CHAR(50) PRIMARY KEY,    
REGION CHAR(50)
);

INSERT INTO LOC_DETAILS      -- LOCATION DETAILS
VALUES
('BOM','WEST'),
('KOC','SOUTH'),
('CHN','SOUTH'),
('BBU','EAST'),
('CCU','EAST'),
('GWT','EAST'),
('DEL','NORTH'),
('IXC','NORTH'),
('AHMD','WEST')
;

SELECT * FROM  ORD_CUST_DETAILS;
--SELECT * FROM LOC_DETAILS;
select * from TRANSAC_PRC_CLASS;

--------

SELECT T.*                  -- ALL COLUMNS FROM TRANSAC_PRC_CLASS WILL COME
		, O.*                   -- ALL COLUMNS FROM ORD_CUST_DETAILS WILL COME
		FROM TRANSAC_PRC_CLASS as T
		LEFT JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID;   -- JOINING CONDITION -- HOW AND ON WHAT WE WANT TO JOIN THE TABLES 


SELECT TRANS.TNXID, TRANS.PRODUCTID, TRANS.PRICE  -- PULLING SPECIFIC INFO FROM TRANSAC_PRC_CLASS
		, OD.CUST_EMAIL  -- PULLING SPECIFIC INFO FROM ORD_CUST_DETAILS

		FROM TRANSAC_PRC_CLASS TRANS
		LEFT JOIN    -- ALL INFORMATION FROM LEFT TABLE + THE MATCHING VALUES FORM THE RIGHT TABLE WILL COME ON WHICH WE ARE JOINING ALONG WITH THE SPEFICIC COLUMNS THAT WE ARE PULLING FROM THE LEFT TABLE -- LEFT TABLE WILL GET PRIORITY -- VALUES WHICH ARENT MATCHING WILL BE POPULATED WILL NULL
		ORD_CUST_DETAILS AS OD

		ON TRANS.TNXID=OD.TNXID;

SELECT * FROM  ORD_CUST_DETAILS;

SELECT O.*,
		T.*
		FROM TRANSAC_PRC_CLASS AS T  
		RIGHT JOIN   -- JUST THE INVERSE OF LEFT JOIN -- if you flip the tables it is same as left join
		ORD_CUST_DETAILS AS O  
		ON 
		T.TNXID=O.TNXID;

SELECT O.*,
		T.*
		FROM TRANSAC_PRC_CLASS AS T
		INNER JOIN   -- COMMON VALUES THAT ARE MATCHING IN BOTH THE TABLES WILL COME AS OUTPUT
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID;

SELECT O.*,
		T.*
		FROM TRANSAC_PRC_CLASS AS T
		FULL OUTER JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID;

SELECT * FROM LOC_DETAILS;
SELECT * FROM ORD_CUST_DETAILS;

SELECT T.*    -- ALL COLUMNS FORM T
		, O.*   -- ALL COLUMNS FROM O
		, L.*  -- ALL COLUMNS FROM L
		FROM TRANSAC_PRC_CLASS AS T   -- JOINING MULTIPLE TABLES ON THE RELEVANT COLUMNS 
		LEFT JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID
		
		LEFT JOIN
		LOC_DETAILS L
		ON L.LOC_NAME=O.CUST_CITY
		;

select t.tnxid, t.productid, t.price   -- PULLING IN ONLY SPECIFIC INFO FROM THE MULTIPLE TABLES 
		, o.cust_city
		,l.region
		from TRANSAC_PRC_CLASS as t
		left join 
		ORD_CUST_DETAILS AS O
		on T.TNXID=O.TNXID

		left join
		LOC_DETAILS as l
		on L.LOC_NAME=O.CUST_CITY;

SELECT T.TNXID
		, T.PRODUCTID
		, T.PRICE
		, T.PRODUCT_CLASS  -- BRING ONE EXTRA COLUMN
		, O.CUST_CITY
		, L.REGION

		FROM TRANSAC_PRC_CLASS AS T
		LEFT JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID
		
		LEFT JOIN
		LOC_DETAILS L
		ON L.LOC_NAME=O.CUST_CITY; 


-- Calc. total revenue generated from each city
SELECT O.CUST_CITY   -- PULLING FROM O TABLE
		, SUM(T.PRICE) REVENUE_GENERATED  -- AGGREGATING ON PRICE COLUMN WHICH WE GOT AFTER JOINING BOTH THE TABLES
		FROM TRANSAC_PRC_CLASS AS T        -- JOIN THE 2 TABLES TO GET THE PRICE AND LOC INFO. 
		LEFT JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID
		GROUP BY O.CUST_CITY; 

		
-- Calc. total revenue generated & AVG DISCOUNT GIVEN - by PRODUCT CLASS from each city
SELECT T.PRODUCT_CLASS
		, O.CUST_CITY
		, SUM(T.PRICE) REVENUE_GENERATED
		, AVG(T.DISC_PEC) AS TOTAL_DISC_GIVEN

		FROM TRANSAC_PRC_CLASS AS T
		LEFT JOIN
		ORD_CUST_DETAILS AS O  -- joining on cust_order_details to get the customer city
		ON 
		T.TNXID=O.TNXID

		GROUP BY  -- grouping by the business use case of how business wants to see the results
		T.PRODUCT_CLASS
		, O.CUST_CITY

		ORDER BY 
		T.PRODUCT_CLASS;

-- PRODUCT_CLASS, REGION, REVENUE_GEN, AVG_DISC
SELECT T.PRODUCT_CLASS
		, L.REGION
		, AVG(T.PRICE) AVG_REVENUE_GENERATED

		FROM TRANSAC_PRC_CLASS AS T

		LEFT JOIN
		ORD_CUST_DETAILS AS O
		ON 
		T.TNXID=O.TNXID

		LEFT JOIN
		LOC_DETAILS L
		ON L.LOC_NAME=O.CUST_CITY

		GROUP BY
		T.PRODUCT_CLASS
		, L.REGION
		
		ORDER BY 
		PRODUCT_CLASS,
		REGION DESC;

-- Calc. contribution of sales for each product class
SELECT PRODUCT_CLASS
		, CONCAT(ROUND((SUM(PRICE)/ (SELECT SUM(PRICE) FROM TRANSAC_PRC_CLASS))*100,2),'%') AS REVENUE_CONTRI_PERC
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCT_CLASS;

SELECT PRODUCT_CLASS
		, SUM(PRICE)/ (SELECT SUM(PRICE) FROM TRANSAC_PRC_CLASS) AS REVENUE_CONTRI_PERC
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCT_CLASS;		

SELECT PRODUCT_CLASS
		, ROUND(SUM(PRICE),2) AS REVENUE_CONTRI_USD
		FROM TRANSAC_PRC_CLASS
		GROUP BY PRODUCT_CLASS;

SELECT ROUND(SUM(PRICE),2) AS TOT_REVENUE_USD
		FROM TRANSAC_PRC_CLASS;

--CALC. CONTRIBUTION OF SALES BY REGION
SELECT L.REGION
		,  CONCAT(ROUND((SUM(T.PRICE)/(SELECT SUM(PRICE) FROM TRANSAC_PRC_CLASS))*100,2),'%') AS REV_CONTRI
		FROM TRANSAC_PRC_CLASS T
		
			LEFT JOIN
			ORD_CUST_DETAILS AS O
			ON 
			T.TNXID=O.TNXID

			LEFT JOIN
			LOC_DETAILS L
			ON L.LOC_NAME=O.CUST_CITY 

			GROUP BY 
			L.REGION;

------------------------------------------
------------------------------------------
------------------------------------------
------------------------------------------

SELECT A.REGION
		, ROUND((A.TOT_REV/(SELECT SUM(PRICE) FROM TRANSAC_PRC_CLASS))*100,2) AS REV_CONTRI  -- IN THE OUTER QUERY DIVIDE THE REGION WISE REVENUE VALUE WITH TOTAL REVENUE GENERATED
		FROM (     
			-- FIRST CALC. THE REGION WISE SALES IN THE INNER QUERY (THAT WILL GENERATE A TABLE AS OUTPUT)
				SELECT L.REGION
					,  SUM(T.PRICE) AS TOT_REV	
					FROM TRANSAC_PRC_CLASS T
		
						LEFT JOIN
						ORD_CUST_DETAILS AS O
						ON 
						T.TNXID=O.TNXID

						LEFT JOIN
						LOC_DETAILS L
						ON L.LOC_NAME=O.CUST_CITY 

						GROUP BY 
						L.REGION
			  ) AS A
		;

--------------------------
-- WINDOW FUNCTIONS --

SELECT * FROM TRANSAC_PRC_CLASS;

--RANK THE SELLING PRICE OF EVERY PRODUCT UNDER EVERY PRODUCTDESC
SELECT PRODUCTDESC      -- PARTITION BY PRODUCT_CLASS IS CREATING GROUPS IN THE TABLE AND RANKING THE TRANSACTION AS PER PRICE VALUES IN THAT PRODUCT_CLASS GROUP
		, PRODUCTID
		, PRICE
		, RANK() OVER (PARTITION BY PRODUCTDESC ORDER BY PRICE DESC) AS RNK_PRICE  -- MENTION THE OPERATION FIRST -- MENTION ON WHICH GROUPS YOU WANT TO DO THE OPERATIONS AND HOW YOU WANT TO DO IT
		FROM TRANSAC_PRC_CLASS
		ORDER BY PRODUCT_CLASS;		


-- GET ME THE PRODUCT CLASS UNDER EVERY REGION THAT IS PERFORMING THE POOREST 
-- FIRST STEP: GET THE REGION-PRODUCT_CLASS WISE REVENUE GENERATED
-- SECOND STEP: RANK THE PRODUCT_CLASS UNDER EVERY REGION PARTITION AS PER THE REVENUE GENERATED
-- THRID STEP: FILTER OUT ONLY THE REGION-PRODUCT_CLASS COMBINATION THAT HAS RANK 1 AS WE ARRANGED IN ASCENDING

SELECT B.* FROM (  -- THIS SUBQUERY GETS IN THE REQUIRED AGGREGATED VALUES FROM THE INNER QUERY AND RANKS ACCORDING TO THE CONDITION
				SELECT A.REGION
						, A.PRODUCT_CLASS
						, A.TOT_REV
						, RANK() OVER (PARTITION BY A.REGION ORDER BY A.TOT_REV) AS RANK_REGION_SALES
						FROM (  -- INNER TABLE GENERATING STEP 1
								SELECT L.REGION   
										, T.PRODUCT_CLASS
									,  SUM(T.PRICE) AS TOT_REV	
									FROM TRANSAC_PRC_CLASS T
		
										LEFT JOIN
										ORD_CUST_DETAILS AS O
										ON 
										T.TNXID=O.TNXID

										LEFT JOIN
										LOC_DETAILS L
										ON L.LOC_NAME=O.CUST_CITY 

										GROUP BY 
										L.REGION
										, T.PRODUCT_CLASS

							 ) A
				) B
			WHERE RANK_REGION_SALES = 1  -- FINALLY FILTERING IT OUT
		;
-- ROW_NUMBER(), DENSE_RANK(), NTILE()

-- PULL OUT THE PRODUCTDESC INFO THAT WAS BOUGHT CONSECUTIVELY 
SELECT A.*,   -- PULLING ALL COLUMNS FROM THE INNER TABLE 
		CASE WHEN A.PRODUCTDESC=A.LAG_PRODDESC THEN 'CONSECUTIVE BUY'
		ELSE 'NON CONSECUTIVE BUY' END AS BUY_FLAG  -- COMPARING THE LAGGED COLUMN VALUE WITH THE BASE TABLE ACTUAL PRODUCTDESC VALUE
		FROM (   --- INNER QUERY WE ARE CREATING THE LAGGED VALUES COLUMN 
				SELECT *
						, LAG(PRODUCTDESC, 1) OVER (ORDER BY TNXID, PRODUCTDESC) AS LAG_PRODDESC   --LAG(PRODUCTDESC, 1) IS PULLING DOWN THE ENTIRE PRODUCTDESC SERIES BY 1 ROW  -- (ORDER BY TNXID, PRODUCTDESC) [HERE IN OUR CASE OUR DATA WAS ALREADY ORDERED IN THIS PARTICULAR FORMAT BUT IN THE SYNTAX WE NEED TO SPECIFY ORDER BY 
						FROM TRANSAC_PRC_CLASS
			 ) A
			 ;

-- ORDER OF EXECUTION -- FROM - WHERE - GROUP BY 
-----------------------------------

CREATE TABLE ProductSales
(
  [Year]  INT
 ,[Quarter] TINYINT
 ,Sales     FLOAT
);
 
INSERT INTO ProductSales VALUES 
 (2017, 1, 55000)
,(2017, 2, 78000)
,(2017, 3, 49000)
,(2017, 4, 32000)
,(2018, 1, 41000)
,(2018, 2, 8965)
,(2018, 3, 69874)
,(2018, 4, 32562)
,(2019, 1, 87456)
,(2019, 2, 75000)
,(2019, 3, 96500)
,(2019, 4, 85236);


SELECT * FROM ProductSales;

-- HOW MUCH GROWTH DID WE DO IN EVERY YEAR QoQ
SELECT P.*
	, ROUND(((P.SALES - P.NEXT_QTR_SALES)/P.SALES)*100,2)  -- (NEXT_QRT_SALES - SALES / NEXT_QRT_SALES)   -- IS_INF (...... , 100)
				FROM   
					(SELECT [Year], 
						   [Quarter], 
						   Sales, 
						   LEAD(Sales, 1, 0) OVER (PARTITION BY [Year] ORDER BY [Year], [Quarter] ASC) AS NEXT_QTR_SALES  
						   -- LEAD(Sales, 1, 0) -- PULLING THE NEXT VALUE UP BY 1 ROW -- (PARTITION BY [Year] -- IT IS FIRST DIVIDING INTO GROUPS ON THE BASIS OF YEAR AND THEN IT IS APPLYING THE LEAD(Sales, 1,0) OPERATION BY PULLING THE VALUES BY 1 ROW UP WITHIN THAT PARTICULAR GROUP 
					       --  ORDER BY [Year], [Quarter] ASC ARRANGING THE DATA FIRST BY YEAR, AND THEN BY QUARTER IN ASCENDING
					FROM ProductSales                                                                                
					) P
;

 -- ANALYZE IN WHICH QUATERS DID WE DO THE MOST SALES AND THE POOREST
 SELECT * FROM ProductSales;
 
 SELECT T.*
		, CASE WHEN T.RANK_SALES=1 THEN 'POOREST' 
				WHEN T.RANK_SALES=4 THEN 'MOST'
				ELSE 'NIL'
				END AS FLAG
				FROM (
						 SELECT *
								, RANK() OVER (PARTITION BY [YEAR] ORDER BY [YEAR], [SALES] ASC) AS RANK_SALES
								FROM ProductSales
					 ) T;

-- ANALYZE WHICH YEAR DID WE DO THE MOST SALES
SELECT [YEAR]
	, SUM(SALES) 
	FROM ProductSales 
	GROUP BY [YEAR] 
	ORDER BY SUM(SALES) DESC;

-- ANALYZE YEAR OVER YEAR GROWTH/DE-GROWTH 
SELECT B.*
	   , CASE WHEN B.PERC_DIFF < 0 THEN 'DE-GROWTH' 
		 ELSE 'GROWTH' END AS GROW_FLAG
		 FROM (
				SELECT A.*
						, LAG(A.TOT_SALES,1,0) OVER (ORDER BY [YEAR]) LAG_SALES
						, ROUND(((A.TOT_SALES - LAG(A.TOT_SALES,1,0) OVER (ORDER BY [YEAR]))/A.TOT_SALES)*100,2) AS PERC_DIFF
						FROM (
								SELECT [YEAR]
									, SUM(SALES) TOT_SALES
									FROM ProductSales 
									GROUP BY [YEAR] 
									--ORDER BY [YEAR]
							 ) A
				) B ;

 -- QoQ GROWTH/DE-GROWTH (NO YEAR IN IT)
SELECT B.*
	   , CASE WHEN B.PERC_DIFF < 0 THEN 'DE-GROWTH' 
		 ELSE 'GROWTH' END AS GROW_FLAG
		 FROM (
				SELECT A.*
						, LAG(A.Sales,1,0) OVER (ORDER BY [YEAR]) LAG_SALES
						, ROUND(((A.Sales - LAG(A.Sales,1,0) OVER (ORDER BY [YEAR]))/A.Sales)*100,2) AS PERC_DIFF
						FROM ProductSales A
				) B ;


-- CALCULATING AVG. DAILY DEMAND (DEMAND PREDICTION USING BASIC MATH)

USE ECOMMERCE;

SELECT * FROM SALES_TRANS;

SELECT D.DATE
		, D.ACTUAL_DEMAND
		, D.AVG_BK_DAILY_DEMAND
		, D.AVG_FWD_DAILY_DEMAND
		, D.AVG_RECENT_BK_DEMAND
		, D.TREND_FACTOR
		, (D.AVG_RECENT_BK_DEMAND * D.TREND_FACTOR) AS RECENT_DEMAND
	  FROM (
			SELECT F.DATE
					, F.ACTUAL_DEMAND
					, F.AVG_BK_DAILY_DEMAND
					, F.AVG_FWD_DAILY_DEMAND
					, F.AVG_RECENT_BK_DEMAND
					, (F.AVG_FWD_DAILY_DEMAND / F.AVG_BK_DAILY_DEMAND) AS TREND_FACTOR
				FROM (
						SELECT DATE
								, ACTUAL_DEMAND
								, ROUND(AVG(ACTUAL_DEMAND) OVER (ORDER BY DATE ROWS BETWEEN 364 PRECEDING AND 350 PRECEDING),2) AS AVG_FWD_DAILY_DEMAND
								, ROUND(AVG(ACTUAL_DEMAND) OVER (ORDER BY DATE ROWS BETWEEN 380 PRECEDING AND 366 PRECEDING),2) AS AVG_BK_DAILY_DEMAND
								, ROUND(AVG(ACTUAL_DEMAND) OVER (ORDER BY DATE ROWS BETWEEN 15 PRECEDING AND 1 PRECEDING),2) AS AVG_RECENT_BK_DEMAND
								FROM SALES_TRANS
						) F
	  		) D
		;

-- [(Z * STDV. DEMAND) + (A * TREND FACTOR)] * (HOLIDAY FACTOR) * (PROMO FACTOR) * (EVENT FACTOR) * (WEEKDAY/WEEKEND FACTOR) 

SELECT *, CONCAT(YEAR(DATE),MONTH(DATE)) AS YEARMONTH FROM SALES_TRANS;
---------------------------

SELECT * FROM TRANSACTION_PRACTICE_DUMMY;

SELECT DISTINCT DATASOURCE FROM TRANSACTION_PRACTICE_DUMMY;

-- CLASSIFY/SEGMENT THE CUSTOMERS ON THEIR PURCHASE PATTERNS 
-- FOR A COMPLETE PURCHASE TO HAPPEN CUSTOMER SHOULDN'T CANCEL OR RETURN THE PRODUCT
-- IF AVG. BUYING FREQUENCY IN BETWEEN PURCHASE DATES ARE THESE BELOW CONDITION THEN TAG AS THEN AS THESE TAGS. 
SELECT C.CUST_ID
		--, COUNT(*)+1 AS NO_OF_TRANS
		, CASE 
				WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) IN (0,1) THEN 'NOT SURE'
				WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) BETWEEN 2 AND 10 THEN 'FREQUENT PURCHASER'
				WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) BETWEEN 11 AND 30 THEN 'REGULAR CUSTOMER'
				WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) > 30 AND AVG(C.DAY_DIFF_FROM_LASTORDER) < 60 THEN 'IRREGULAR CUSTOMER'
				ELSE 'NO PATTERN'
				END AS CUSTOMER_PURCHASE_PATTERN 
		FROM (

			SELECT B.CUST_ID
					, B.ORDER_DATETIME
					, B.LAST_DATE
					, DATEDIFF(DAY, B.ORDER_DATETIME, B.LAST_DATE) AS DAY_DIFF_FROM_LASTORDER
					FROM (

							SELECT A.CUST_ID
									, A.ORDER_DATETIME
									, LAG(A.ORDER_DATETIME,1) OVER (PARTITION BY A.CUST_ID ORDER BY A.ORDER_DATETIME DESC) AS LAST_DATE
									FROM (

											SELECT AMPERITY_ID AS CUST_ID
													, ORDER_DATETIME
													FROM TRANSACTION_PRACTICE_DUMMY
													WHERE 
													IS_RETURN=0
													AND IS_CANCELLATION=0
													--ORDER BY ORDER_DATETIME DESC
										) A 

						) B 

			) C
		WHERE DAY_DIFF_FROM_LASTORDER IS NOT NULL
		GROUP BY C.CUST_ID;

------------------------------------------------------------------------------------------------------
SELECT AMPERITY_ID, DATASOURCE, ITEM_QUANTITY FROM TRANSACTION_PRACTICE_DUMMY where AMPERITY_ID='16d19f40-0163-33b9-b44a-97d2920909de';

--CUSTOMER WISE ECOM & POS QUANTITY PURCHASED
SELECT AMPERITY_ID AS CUST_ID
		, SUM (CASE WHEN DATASOURCE='CDT_ECOM_UIT' THEN ITEM_QUANTITY END) AS ECOM_PURCHASED
		, SUM (CASE WHEN DATASOURCE='CDT_POS_UIT' THEN ITEM_QUANTITY END) AS POS_PURCHASED
		FROM TRANSACTION_PRACTICE_DUMMY
		WHERE 
		IS_RETURN=0
		AND IS_CANCELLATION=0
		AND AMPERITY_ID='16d19f40-0163-33b9-b44a-97d2920909de'
		GROUP BY 
		AMPERITY_ID
;

SELECT AMPERITY_ID
		, PRODUCT_GENDER
		, SUM(ITEM_QUANTITY) AS TOTAL_QTY
		FROM TRANSACTION_PRACTICE_DUMMY
		WHERE 
		IS_RETURN=0
		AND IS_CANCELLATION=0
		AND AMPERITY_ID='16d19f40-0163-33b9-b44a-97d2920909de'
		GROUP BY 
		AMPERITY_ID
		, PRODUCT_GENDER;

SELECT * FROM TRANSACTION_PRACTICE_DUMMY;

--FIND THE NO. OF ITEMS PURCHASED UNDER PRODUCT GENDER BY EVERY CUSTOMER  
SELECT AMPERITY_ID
		, Womens
		, Girls
		, Boys
		, Unisex
		, Mens 
		FROM     
			(SELECT AMPERITY_ID
					, PRODUCT_GENDER
					, ITEM_QUANTITY 
					FROM TRANSACTION_PRACTICE_DUMMY 
					WHERE 
					IS_RETURN=0
					AND IS_CANCELLATION=0) AS A    
		PIVOT    
		(SUM(ITEM_QUANTITY) FOR PRODUCT_GENDER IN (Womens, Girls, Boys, Unisex, Mens)) AS B ;   

--FIND THE TOTAL ITEMS SOLD, TOTAL REV. GENERATED, ECOM REV. GENERATED, POS REV. GENERATED, ITEMS RETURNED, ITEMS CALNCELLED FOR EVERY BRAND 
SELECT PRODUCT_BRAND
		, SUM (CASE WHEN IS_RETURN=0 AND IS_CANCELLATION=0 THEN ITEM_QUANTITY END) AS BRAND_ITEMS_SOLD
		, ROUND (SUM (CASE WHEN IS_RETURN=0 AND IS_CANCELLATION=0 THEN ITEM_REVENUE END), 2) AS BRAND_REVENUE_GENERATED
		, ROUND (SUM (CASE WHEN DATASOURCE='CDT_ECOM_UIT' AND IS_RETURN=0 AND IS_CANCELLATION=0 THEN ITEM_REVENUE END), 2) AS BRAND_ECOM_REVENUE_GENERATED
		, ROUND (SUM (CASE WHEN DATASOURCE='CDT_POS_UIT' AND IS_RETURN=0 AND IS_CANCELLATION=0 THEN ITEM_REVENUE END), 2) AS BRAND_POS_REVENUE_GENERATED
		, ABS (SUM (CASE WHEN IS_RETURN=1 AND IS_CANCELLATION=0 THEN ITEM_QUANTITY END)) AS BRAND_ITEMS_RETURNED
		, SUM (CASE WHEN IS_RETURN=0 AND IS_CANCELLATION=1 THEN ITEM_QUANTITY END) AS BRAND_ITEMS_CANCELLED
		FROM TRANSACTION_PRACTICE_DUMMY
		GROUP BY PRODUCT_BRAND
		ORDER BY BRAND_REVENUE_GENERATED DESC;

SELECT STORE_ID
		, PRODUCT_SIZE
		, COUNT(*) NO_OF_SIZES_BOUGHT
		FROM TRANSACTION_PRACTICE_DUMMY
		WHERE STORE_ID!=789
		GROUP BY 
		STORE_ID
		, PRODUCT_SIZE
		ORDER BY 
		STORE_ID
		, PRODUCT_SIZE
;

SELECT DISTINCT YEAR(ORDER_DATETIME) FROM TRANSACTION_PRACTICE_DUMMY;


SELECT STORE_ID
		, CASE WHEN YEAR_NO=2019 THEN PRODUCT_COLOR END AS COLOR_2019
		, CASE WHEN YEAR_NO=2020 THEN PRODUCT_COLOR END AS COLOR_2020
		, CASE WHEN YEAR_NO=2021 THEN PRODUCT_COLOR END AS COLOR_2021
		, CASE WHEN YEAR_NO=2022 THEN PRODUCT_COLOR END AS COLOR_2022
		, CASE WHEN YEAR_NO=2023 THEN PRODUCT_COLOR END AS COLOR_2023
		, CASE WHEN YEAR_NO=2024 THEN PRODUCT_COLOR END AS COLOR_2024
		FROM (
				SELECT STORE_ID
						, YEAR_NO
						, PRODUCT_COLOR
						, DENSE_RANK() OVER (PARTITION BY STORE_ID, YEAR_NO ORDER BY ITEMS_BOUGHT DESC) AS COLOR_RNK
						FROM 
							(SELECT STORE_ID
									, YEAR(ORDER_DATETIME) YEAR_NO
									--, STORE_ID
									, PRODUCT_COLOR
									, COUNT(*) AS ITEMS_BOUGHT
									FROM TRANSACTION_PRACTICE_DUMMY
									WHERE STORE_ID!=789
									GROUP BY 
									--YEAR(ORDER_DATETIME)
									STORE_ID
									, YEAR(ORDER_DATETIME)
									, PRODUCT_COLOR
							) A
		) B
		WHERE COLOR_RNK=1
		--GROUP BY STORE_ID
;

-----------------------------------------

CREATE DATABASE RETURNS_PRACTICE;

USE RETURNS_PRACTICE;

CREATE TABLE TRANSACTION_V1
( CUSTOMER_ID VARCHAR(255)
, ORDER_DATETIME DATE
, ORDER_ID VARCHAR(255)
, PRODUCT_ID VARCHAR(255)
, ITEM_QUANTITY INT
, IS_RETURN VARCHAR(255)
, IS_CANCELLATION VARCHAR(255)
, ITEM_REVENUE FLOAT
);

INSERT INTO TRANSACTION_V1 VALUES
('1001','2022-01-13','2001','P1',1,'FALSE','FALSE',40.50)
,('1001','2022-01-21','2001','P2',-1,'TRUE','FALSE',14.50)

,('1002','2022-02-21','2002','P5',1,'FALSE','FALSE',20.60)

,('1003','2022-02-11','2011','P3',1,'FALSE','FALSE',50.20)
,('1003','2022-02-11','2011','P4',-1,'TRUE','FALSE',17.50)
,('1003','2022-01-11','2011','P1',-1,'TRUE','FALSE',29.30)

,('1001','2022-03-13','2009','P4',1,'FALSE','FALSE',30.50)

,('1004','2022-02-13','2023','P5',-1,'TRUE','FALSE',10.70)

,('1005','2022-03-10','2021','P1',-1,'TRUE','FALSE',26.50)

,('1006','2022-02-16','2045','P6',1,'FALSE','FALSE',55.50)
,('1006','2022-02-16','2045','P1',1,'FALSE','FALSE',49.50)

,('1007','2022-01-10','2020','P9',1,'FALSE','FALSE',90.50)

,('1008','2022-01-15','2019','P1',-1,'TRUE','FALSE',16.80)
,('1008','2022-01-16','2030','P1',1,'FALSE','FALSE',80.50)

,('1009','2022-03-13','2015','P3',1,'FALSE','FALSE',40.50)

,('1010','2022-03-13','2012','P8',1,'FALSE','FALSE',40.50)

,('1011','2022-03-13','2013','P4',-1,'TRUE','FALSE',32.30)

,('1012','2022-02-13','2099','P1',1,'FALSE','FALSE',40.50)

,('1013','2022-01-13','2081','P3',1,'FALSE','FALSE',40.50)

,('1014','2022-01-13','2071','P5',-1,'TRUE','FALSE',18.90)
;

SELECT * FROM TRANSACTION_V1;

CREATE TABLE CUST_360_INFO_V1
( CUST_ID VARCHAR(255)
, CUSTOMER_SEGMENTS VARCHAR(255)
, TIER_NAME VARCHAR(255)
, LAST_ACTIVITY_DATE DATE
);

INSERT INTO CUST_360_INFO_V1 VALUES
('1001','CLASSIC','ICON','2022-01-10')
,('1002','TREND DEE','DEVOTEE','2022-01-23')
,('1001','CLASSIC','OFFICIAL','2022-01-24')
,('1003','FASHION','OFFICIAL','2022-01-27')
,('1004','TREND DEE','DEVOTEE','2022-03-19')
,('1005','TREND DEE','OFFICIAL','2022-02-14')
,('1002','TREND DEE','ICON','2022-02-23')
,('1006',NULL,'ICON','2022-02-24')
,('1007',NULL,'DEVOTEE','2022-02-25')
,('1008','CLASSIC','ICON','2022-03-12')
,('1009',NULL,NULL,'2022-01-09')
,('1010',NULL,NULL,'2022-03-14')
,('1011',NULL,'DEVOTEE','2022-02-15')
,('1012','FASHION','OFFICIAL','2022-01-19')
,('1013','CLASSIC',NULL,'2022-03-23')
,('1014','TREND DEE','ICON','2022-03-23')
;


SELECT * FROM CUST_360_INFO_V1;

CREATE TABLE CUSTSEGROLL_V1 
( CUSTOMER_ID VARCHAR(255)
, SEGMENT VARCHAR(255)
);

INSERT INTO CUSTSEGROLL_V1 VALUES
('1001','CLASSIC')
,('1005','TREND DEE')
,('1006','FASHION')
,('1007','FASHION')
,('1009',NULL)
,('1010','CLASSIC')
,('1011','TREND DEE')
;

SELECT * FROM CUSTSEGROLL_V1;

CREATE TABLE CALENDER
( DAY_NAME DATE,
 MONTH_NUMBER INT);

INSERT INTO CALENDER VALUES
('2022-01-10',1)
,('2022-01-23',1)
,('2022-01-24',1)
,('2022-01-27',1)
,('2022-03-19',3)
,('2022-02-14',2)
,('2022-02-23',2)
,('2022-02-24',2)
,('2022-02-25',2)
,('2022-03-12',3)
,('2022-01-09',1)
,('2022-03-14',3)
,('2022-02-15',2)
,('2022-01-19',1)
,('2022-03-23',3)
;

 SELECT * FROM CALENDER;
 
 CREATE TABLE ORDER_RETTYPE (
  ORDER_NO VARCHAR(255)
, SKU_NO VARCHAR(255)
, RETURN_TYPE VARCHAR(255)
);

INSERT INTO ORDER_RETTYPE VALUES 
('2001','P2','Dc return')
,('2011','P4','DC return')
,('2011','P1','Store return')
,('2023','P5','dc return')
,('2021','P1','store return')
,('2019','P1','DC return')
,('2013','P4','store return')
,('2071','P5','Store return')
;

-- PERFORM ANALYSIS TO SEE FROM WHERE DO WE GET THE MOST RETURNS?

-- STEP 1: FIRST CREATE A TABLE THAT HAS CUSTOMER WISE INFORMATION  (HERE WE HAVE TAKEN CUSTOMER, MONTH WISE TRASANCTION INFORMATION)
-- STEP 2: PRE PROCESS THE REQUIRED INFOS FROM EACH OF THESE TABLES AND BRING DATA AT A CUSTOMER LEVEL
-- STEP 3: IN THE FINAL QUERY JOIN ALL THE INFORMNATIONS AND CREATE A FINAL DATASET THAT HAS ALL THE POSSIBLE REASONS/INFORMATIONS ON WHICH AN RCA CAN BE DONE
GO
CREATE VIEW RETURNS_ANALYSIS_TABLE AS   --CREATING A VIEW FOR THIS EVERY DATASET CREATED BY JOINING MULTIPLE TABLE AND DOING MULTIPLE OPERATIONS

WITH LOYALTY AS (   -- THIS CTE IS PULLING OUT THE LATEST LOYALTY TIER VALUES OF EVERY CUSTOMER
				 SELECT A.CUST_ID, A.TIER_NAME FROM (    -- SO THE INNER TABLE IS FIRST CREATING THE ROW NUMBER COLUMN ACCORDING TO WHICH WE WANT TO FILTER
													 SELECT *      -- FOR EVERY CUSTOMER IT IS GROUPING THE RECORDS OF THE CUSTOMER AND ORDERING BY DESC W.R.T THE LAST_ACTIVITY_DATE 
															, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY LAST_ACTIVITY_DATE DESC) AS LOYALTY_ROW_NUM 
													 FROM CUST_360_INFO_V1
												    ) A
				 WHERE A.LOYALTY_ROW_NUM = 1  -- FILTERING OUT WHERE ROW NUMBER IS 1 AS IT INDICATES THE LAST ACTIVITY
				 ),

CUSTSEG AS (SELECT DISTINCT A.CUSTOMER_ID      -- THIS CTE IS INCREASING THE COVERAGE OF THE CUSTOMER SEGMENTS I.E. FILLING IN THE NULL VALUES
					, COALESCE (CR.SEGMENT,C.CUSTOMER_SEGMENTS) AS CUSTOMER_SEG  --COALESCE WHICH IS FILLING IN THE NULL VALUES BY PULLING VALUES FROM OTHER TABLES AND COLUMNS AS MENTIONED
					FROM TRANSACTION_V1 A   -- WE WANT ALL CUSTOMERS FORM THE TRANSACTION TABLE I.E. WHY WE ARE TAKING IT AS THE BASE TABLE I.E. THE LEFT MOST TABLE
					LEFT JOIN CUST_360_INFO_V1 C  -- JOIN ON THIS TABLE TO GET IN THE CUSTOMER SEG INFO
					ON A.CUSTOMER_ID=C.CUST_ID
					LEFT JOIN CUSTSEGROLL_V1 CR  -- JOIN ON THIS TABLE TO GET IN THE CUSTOMER INFO, BY DOING A COALESCE WHICH IS FILLING IN THE NULL VALUES
					ON CR.CUSTOMER_ID=A.CUSTOMER_ID
			)

SELECT T.CUSTOMER_ID
		, C.CUSTOMER_SEG  -- THIS CUSTOMER_SEG NOW HAS MORE COVERAGE SINCE WE HAVE DONE A COALESCE WITH MULTIPLE TABLES IN THE ABOVE CTE CUTSEG
		, L.TIER_NAME
		, MONTH(T.ORDER_DATETIME) AS MONTH_NUM  -- EXTRACTING OUT MONTH FROM THE ORDER DATE TIME

		-- THIS CASE WHEN STATEMENT SUMS UP ALL THE VALUES I.E. ITEM PRICE FOR EVERY CUSTOMER-MONTH_NUM CONBINATION WHEREVER IS_RETURN='FALSE' AND IS_CANCELLATION='FALSE' -- THUS IT RETURNS GROSS SALES FOR ALL CUSTOMERS-MONTH_NUM (EVERY CUSTOMER, IN EVERY MONTH)
		, ISNULL(SUM(ABS(CASE WHEN T.IS_RETURN='FALSE' AND T.IS_CANCELLATION='FALSE' THEN T.ITEM_REVENUE END)),0) AS GROSS_SALES  
		, ISNULL(SUM(ABS(CASE WHEN T.IS_RETURN='TRUE' AND T.IS_CANCELLATION='FALSE' THEN T.ITEM_REVENUE END)),0) AS GROSS_RETURNS  -- SIMILARLY LIKE THE PREIOUS ONE BUT ONLY TAKES INTO ACCOUNT THE RETURN ORDERS

		-- THIS CASE WHEN STATEMENT SUMS UP ALL THE VALUES I.E. QUANTITIES FOR EVERY CUSTOMER-MONTH_NUM CONBINATION WHEREVER IS_RETURN='FALSE' AND IS_CANCELLATION='FALSE'  -- RETURNS GROSS ITEMS ORDERED BY EVERY CUSTOMER, IN EVERY MONTH
		, ISNULL(SUM(ABS(CASE WHEN T.IS_RETURN='FALSE' AND T.IS_CANCELLATION='FALSE' THEN T.ITEM_QUANTITY END)),0) AS GROSS_ITEMS_ORDERED
		, ISNULL(SUM(ABS(CASE WHEN T.IS_RETURN='TRUE' AND T.IS_CANCELLATION='FALSE' THEN T.ITEM_QUANTITY END)),0) AS GROSS_ITEMS_RETURNED

		FROM TRANSACTION_V1 T   --TAKING TRANSACTION AS THE BASE TABLE SINCE WE WANT ALL CUSTOMER TRANSACTION INFO
		LEFT JOIN LOYALTY L    -- JOIN ON LOYALTY CTE I.E. TEMP TABLE TO PULL IN THE LATEST ACTIVITY LOYALTY INFO.
		ON T.CUSTOMER_ID=L.CUST_ID

		LEFT JOIN CUSTSEG C  -- JOIN ON CUSTSEG CTE I.E. TEMP TABLE TO PULL IN THE CUSTOMER SEGMENTS
		ON C.CUSTOMER_ID=T.CUSTOMER_ID

		--LEFT JOIN CALENDER CA
		--ON CA.DAY_NAME = T.ORDER_DATETIME

		GROUP BY T.CUSTOMER_ID, CUSTOMER_SEG, TIER_NAME, MONTH(T.ORDER_DATETIME)  -- GROUP BY ALL THE COLUMNS PRESENT BEFORE THE AGGREGATIONS I.E. GROUPING IT BY EVERY CUSTOMER'S MONTH WISE TRABSACTION INFO
		;
GO		
		
-- analysis		
SELECT * FROM TRANSACTION_V1;

SELECT * FROM RETURNS_ANALYSIS_TABLE;  -- PRINTING THE VIEW I.E. THE RUNNING THE ENTIRE CODE CHUNK PRESENT IN IT AND CREATING THE TABLE AS AN OUTPUT

SELECT SUM(GROSS_SALES) TOT_SALES, SUM(GROSS_RETURNS) TOT_RET_REV FROM RETURNS_ANALYSIS_TABLE;  -- SUM(GROSS_SALES) SUMMING UP ALL SALES VALUES WILL GIVE ME TOTAL SALES --SUM(GROSS_RETURNS) SUMMING UP ALL RETURN SALES VALUES WILL GIVE ME TOTAL RETURN SALES

-- CALC. CUSTOMER SEGMENT WISE RETURN RATE
SELECT CUSTOMER_SEG, SUM(GROSS_RETURNS)/SUM(GROSS_SALES) AS CUSTSEG_WISE_RETRATE FROM RETURNS_ANALYSIS_TABLE GROUP BY CUSTOMER_SEG; 



---------------------------------------------------------------------------------

USE ECOMMERCE;
SELECT TOP 100 * FROM TRANSACTION_PRACTICE_DUMMY;

WITH PURCHASE_FREQ AS (
						SELECT C.CUST_ID
							, AVG(C.DAY_DIFF_FROM_LASTORDER) AS PURCHASE_FREQ
							, CASE 
									WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) IN (0,1) THEN 'NOT SURE'
									WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) BETWEEN 2 AND 10 THEN 'FREQUENT PURCHASER'
									WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) BETWEEN 11 AND 30 THEN 'REGULAR CUSTOMER'
									WHEN AVG(C.DAY_DIFF_FROM_LASTORDER) > 30 AND AVG(C.DAY_DIFF_FROM_LASTORDER) < 60 THEN 'IRREGULAR CUSTOMER'
									ELSE 'NO PATTERN'
									END AS CUSTOMER_PURCHASE_PATTERN 
							FROM (

								SELECT B.CUST_ID
										, B.ORDER_DATETIME
										, B.LAST_DATE
										, DATEDIFF(DAY, B.ORDER_DATETIME, B.LAST_DATE) AS DAY_DIFF_FROM_LASTORDER
										FROM (

												SELECT A.CUST_ID
														, A.ORDER_DATETIME
														, LAG(A.ORDER_DATETIME,1) OVER (PARTITION BY A.CUST_ID ORDER BY A.ORDER_DATETIME DESC) AS LAST_DATE
														FROM (

																SELECT AMPERITY_ID AS CUST_ID
																		, ORDER_DATETIME
																		FROM TRANSACTION_PRACTICE_DUMMY
																		WHERE 
																		IS_RETURN=0
																		AND IS_CANCELLATION=0
																		--ORDER BY ORDER_DATETIME DESC
															) A 

											) B 

										) C
							WHERE DAY_DIFF_FROM_LASTORDER IS NOT NULL
							GROUP BY C.CUST_ID
), 

CNT_TRANS AS (
				SELECT A.CUST_ID
						, (A.TOTAL_STORE_PURCHASE + A.TOTAL_ONLINE_PURCAHSE) AS TOTAL_PURCHASES
						FROM (
								SELECT AMPERITY_ID AS CUST_ID
										, COUNT(FK_STORE_TXN) TOTAL_STORE_PURCHASE
										, COUNT(FK_WEB_TXN) TOTAL_ONLINE_PURCAHSE
										FROM TRANSACTION_PRACTICE_DUMMY 
										WHERE 
										IS_RETURN=0
										AND IS_CANCELLATION=0 
										GROUP BY AMPERITY_ID
						     ) A
), 
-- SELECT AMPERITY_ID, FK_STORE_TXN, FK_WEB_TXN 
-- FROM TRANSACTION_PRACTICE_DUMMY
-- WHERE AMPERITY_ID='e5f64006-15ce-3ed9-8bb3-caa9f059235e';
RECENCY AS (

	--SELECT MIN(LAST_PURCHASED), MAX(LAST_PURCHASED) FROM (
			 SELECT CUST_ID 
			 		, ABS (DATEDIFF (DAY, GETDATE(), ORDER_DATETIME)) AS LAST_PURCHASED
			 FROM (
					SELECT AMPERITY_ID CUST_ID
							, ORDER_DATETIME 
							, ROW_NUMBER() OVER (PARTITION BY AMPERITY_ID ORDER BY ORDER_DATETIME DESC) LATEST_PURCHASE_DATE
							FROM TRANSACTION_PRACTICE_DUMMY
			 ) B
			 WHERE LATEST_PURCHASE_DATE = 1
	--) C
), 

MONETORY AS ( 
				SELECT AMPERITY_ID AS CUST_ID
						, ROUND(SUM(ITEM_COST), 2) AS REVENUE_GENERATED
						FROM TRANSACTION_PRACTICE_DUMMY
						WHERE 
						IS_RETURN=0
						AND IS_CANCELLATION=0 
						GROUP BY AMPERITY_ID
)

SELECT C.CUST_ID
		, C.TOTAL_PURCHASES
		, F.PURCHASE_FREQ
		, F.CUSTOMER_PURCHASE_PATTERN
		, R.LAST_PURCHASED
		, M.REVENUE_GENERATED

		FROM CNT_TRANS C
		LEFT JOIN PURCHASE_FREQ F
		ON C.CUST_ID=F.CUST_ID

		LEFT JOIN RECENCY R
		ON C.CUST_ID=R.CUST_ID

		LEFT JOIN MONETORY M 
		ON C.CUST_ID=M.CUST_ID
;

-----------------------------------------
USE ECOMMERCE;

SELECT * FROM TRANS;

GO
CREATE PROCEDURE PRODDESC_FILTER 
@desc varchar(50)
AS
SELECT * FROM TRANS WHERE PRODUCTDESC = @desc;
GO

EXEC PRODDESC_FILTER @desc = 'PANT';


-- Assuming you have an Employee table with Working_hours column

--DROP TABLE Employee_V1;
-- Create a trigger to prevent negative values in Working_hours
-- Assuming you have an Employee table with Working_hours column
CREATE TABLE Employee_V1 (
    EmployeeID INT PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Working_hours INT
);

-- Create a trigger to prevent negative values in Working_hours
GO
CREATE TRIGGER PreventNegativeWorkingHours_V1
ON Employee_V1
INSTEAD OF INSERT
AS
BEGIN
    --SET NOCOUNT ON;

    -- Inserting into the table
    INSERT INTO Employee_V1 (EmployeeID, FirstName, LastName, Working_hours)
    SELECT 
        EmployeeID,
        FirstName,
        LastName,
        CASE WHEN Working_hours < 0 THEN 0 ELSE Working_hours END
    FROM inserted;
END;
GO

INSERT INTO Employee_V1 (EmployeeID, FirstName, LastName, Working_hours)
VALUES (1, 'John', 'Doe', -10);

-- Selecting the record to verify the Working_hours value
SELECT * FROM Employee_V1 WHERE EmployeeID = 1;


--DROP TABLE EMP;
--DROP TABLE emp_audit;

-- Assuming you have an emp table and emp_audit table
-- Assuming you have an emp table and emp_audit table
CREATE TABLE emp (
    EmployeeID INT PRIMARY KEY,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Salary DECIMAL(10, 2)
);

CREATE TABLE emp_audit (
    --AuditID INT PRIMARY KEY IDENTITY(1,1),
    EmployeeID INT,
    FirstName NVARCHAR(50),
    LastName NVARCHAR(50),
    Salary DECIMAL(10, 2),
    AuditDateTime DATETIME
);

-- Create an AFTER INSERT trigger to insert into emp_audit
GO
CREATE TRIGGER InsertIntoEmpAudit_V2
ON emp
AFTER INSERT
AS
BEGIN
    --SET NOCOUNT ON;

    INSERT INTO emp_audit ( EmployeeID, FirstName, LastName, Salary, AuditDateTime)
    SELECT
        --NEWID(),  -- This is just an example, you might want to generate a unique value for AuditID
        i.EmployeeID,
        i.FirstName,
        i.LastName,
        i.Salary,
        GETDATE()  -- Current timestamp
    FROM inserted i;
END;
GO
-- Inserting a record into emp table
INSERT INTO emp (EmployeeID, FirstName, LastName, Salary)
VALUES (1, 'John', 'Doe', 50000.00);

SELECT * FROM emp_audit WHERE EmployeeID = 1;

-----------------------

USE ECOMMERCE;

SELECT * FROM TRANSACTION_PRACTICE_DUMMY;

-- GET THE TOP PERFORMING STORES FROM EVERY YEAR
SELECT YEAR_DATE
		, STORE_NAME
		FROM (
				SELECT YEAR_DATE
						, STORE_NAME
						, RANK() OVER (PARTITION BY YEAR_DATE ORDER BY TOTAL_SALES_STORE DESC) AS STORE_SALES_RNK
						FROM 
							(SELECT YEAR(ORDER_DATETIME) AS YEAR_DATE
												, STORE_NAME
												, ROUND(SUM(ITEM_REVENUE),2) AS TOTAL_SALES_STORE
												FROM TRANSACTION_PRACTICE_DUMMY
												WHERE STORE_NAME NOT IN ('WEB')
												GROUP BY 
												YEAR(ORDER_DATETIME)
												, STORE_NAME
							) A
		) B 
		WHERE STORE_SALES_RNK = 1
;

SELECT SUM(ITEM_REVENUE) AS TOT_REV
		, 0.8*SUM(ITEM_REVENUE) AS TOT_REV_80PER
		FROM TRANSACTION_PRACTICE_DUMMY;


SELECT
        PRODUCT_BRAND,
        --ProductName,
        TOT_BRAND_REV,
        PERCENT_RANK() OVER (ORDER BY TOT_BRAND_REV DESC) AS CumulativePercentage
    FROM (
			SELECT PRODUCT_BRAND
					, SUM(ITEM_REVENUE) AS TOT_BRAND_REV
					FROM TRANSACTION_PRACTICE_DUMMY
					GROUP BY PRODUCT_BRAND
	) A;

-- WITH BRANDORD AS (
-- SELECT PRODUCT_BRAND
-- 					, SUM(ITEM_REVENUE) AS TOT_BRAND_REV
-- 					FROM TRANSACTION_PRACTICE_DUMMY
-- 					GROUP BY PRODUCT_BRAND
-- 					ORDER BY SUM(ITEM_REVENUE)
-- 				)



